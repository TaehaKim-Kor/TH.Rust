fn summation(a: i8, b: i8, k: i8) -> i8{ //이 화살표와 출력값을 적어주지 않으면 에러가 발생
    let z = a+b-k;
    return z
}



fn main() {
    //변수 선언은 let {변수이름}: {변수형태} = {변수값};으로 선언한다.
    //이렇게 선언된 변수는 차후에 값을 수정할 수 없다.
    let x: i8 = 5;
    // x = x+1; => 이건 불가능, 값을 직접 수정하는 것은 안 됨.
    //그러면, 값을 수정하기 위한 변수는 어떻게 선언해야하지?
    //수정 가능한 변수는 let mut {변수이름}: {변수 형태} = {변수값};으로 선언한다.
    let mut y: i8 = 4;
    //이렇게 해주는 이유는 값의 수정 여부를 명시적으로 결정하는 것이
    //SW debug에도 좋고 가독성도 좋아져서임.
    //값을 수정하지 못하면 const냐고 물어볼 수 있지만 그것은 또 아니다.
    // x = x+1; 이건 오류가 나지만
    let x: i8 = x+1; //이건 오류가 발생하지 않는다. 변수를 새로 생성하는 개념이기 때문임.
    y = y+1; //이건 mut을 붙였기 때문에 오류가 발생하지 않는다.
    const K: i8 = 127; //절대 뒤져도 안 바뀜! 값, type 모두 바꿀수 없음!
    //와 int8에 255넣으니까 -128~127까지만 넣으라고 알려주네 ㅋㅋㅋㅋ 짱이당.

    //중괄호가 안에서는 같은 변수라도 조금 다르다. 지역 변수처럼
    {
        let x:i8 = x*2;
        println!("X value in the box is {}", x); // 12가 출력됨
    }
    println!("X value away from the box is {}",x); // 6이 출력됨.
    //문자열을 생성해보자.
    let _mystring: &str = "   ";
    //띄어쓰기를 3번했는데 이러면 길이가 3임.
    let _mystring: usize = _mystring.len();
    //let을 통해서도 변수의 타입을 바꿀 수 있음! -> 새로 생성되는 변수
    let mut _mystring2 : &str = "   ";
    //mystring2 = mystring2.len(); 
    //이건 안될 것임. 문자열 type에서 숫자형 type으로 넣으려니 에러 발생
    println!("Y value is {}",y);
    //함수를 만들어보자.
    let z = summation(x,y,K); // 6 + 5 - 127 = -116
    println!("Z value is {}", z) // -116이 나와야함.
    //심지어 모종의 프로그래밍 규칙도 알려준다. 이거 진짜 재밌고 매섭고 맵네 ㅋㅋㅋㅋ.
}
